def zero_aware_qcut(df, col, q=3, new_col_suffix='_bin'):
    """
    Applies qcut binning to non-zero values and assigns 'none' to zero values.
    Handles duplicate bin edges and dynamically adjusts bin labels.
    """
    new_col = col + new_col_suffix
    nonzero_mask = df[col] != 0
    nonzero_values = df.loc[nonzero_mask, col]

    try:
        # Get bin edges with duplicates dropped
        _, bin_edges = pd.qcut(nonzero_values, q=q, retbins=True, duplicates='drop')

        # Adjust labels dynamically based on bin count
        num_bins = len(bin_edges) - 1
        labels = [f'bin_{i}' for i in range(num_bins)]

        # Apply qcut with dynamic labels
        df.loc[nonzero_mask, new_col] = pd.qcut(
            nonzero_values,
            q=num_bins,
            labels=labels,
            duplicates='drop'
        )
    except ValueError as e:
        print(f"Skipping column '{col}' due to qcut error: {e}")
        df[new_col] = 'error'

    # Label 0s as 'none'
    df.loc[~nonzero_mask, new_col] = 'none'
    return df



cols_to_bin = ['connected_party_count', 'shared_address_count', 'shared_device_count']

for col in cols_to_bin:
    df = zero_aware_qcut(df, col, q=3, labels=['low', 'medium', 'high'])
